# AnyGate — Техническое задание

## Миссия

Единый сверхпроизводительный reverse-proxy и сервер статики, способный заменить nginx и traefik как «одну строку для SPA», конкурировать с HAProxy по задержкам и пропускной способности, обеспечивать декларативную маршрутизацию, мгновенные фиксированные ответы, диагностический echo и гибкие плагины. Лицензия — MIT.

## Язык и целевые платформы

Rust стабильной ветки. Linux на x86-совместимой архитектуре — приоритет. macOS и Windows — best effort. Контейнерная упаковка без лишних зависимостей, запуск под непривилегированным пользователем.

## Архитектура ядра

### Рантайм и сетевой цикл

Собственный асинхронный рантайм уровня ядра продукта:

* реактор на epoll с поддержкой edge-triggered режима, таймер-колёсом и неблокирующими сокетами;
* планировщик задач с фиксированными воркерами и work-stealing;
* пул сетевых буферов с аренами, выделение без фрагментации, повторное использование;
* опциональная сборка с io_uring как фича, включаемая отдельно;
* опциональный совместимый режим с экосистемой tokio как фича, выключена по умолчанию.

### Протоколы

* HTTP классический и HTTP с мультиплексированием кадров в обе стороны;
* TLS через rustls, поддержка ALPN, session cache и OCSP stapling;
* HTTP поверх QUIC как фича, выключена по умолчанию;
* gRPC passthrough при HTTP с мультиплексированием кадров и h2c.

### Пайплайн запроса

ACCEPT → PARSE → MATCH → PRE → ACTION → POST → WRITE
Фазы PRE/POST — массив моноформных фильтров без виртуализации в горячем пути. ACTION выбирается на этапе MATCH и инлайнится.

### Маршрутизатор

Компактный radix-trie по сегментам пути с битовой маской методов и приоритетом по специфичности:

* точное совпадение, параметр `:name`, маска `*` (splat);
* предкомпиляция DSL в промежуточное представление и размещение в аренах;
* атомарная замена дерева маршрутов при hot-reload через RCU.

### Действия

* Fixed: мгновенный ответ статусом и, при наличии, телом без аллокаций в горячем пути;
* Echo: диагностический ответ с метаданными запроса и опциональным статусом;
* Static: раздача файлов через sendfile, fallback на mmap и writev, поддержка ETag, Last-Modified, range, index и SPA-fallback, опциональная компрессия gzip, brotli, zstd;
* Proxy: клиент на неблокирующих сокетах с пулами соединений, поддержка HTTP классического и с мультиплексированием, настройка таймаутов подключения, чтения и записи, переписывание Host, заголовки X-Forwarded и Forwarded, балансировка по наборам апстримов, retries для идемпотентных методов, circuit-breaker, fair-очереди ожиданий.

### Раздача файлов

* sendfile при наличии прямого сокета, иначе mmap для мелких объектов, writev для склеивания заголовков и тела;
* кэш метаданных и слабых/сильных ETag, LRU для часто запрашиваемых мелких объектов;
* автоопределение предварительно сжатых ресурсов и отдача по согласованию с клиентом.

### Апстрим-клиент

* отдельные пулы на апстрим и на схему протокола;
* лимиты на общее и простаивающее число соединений, fair-диспетчер ожиданий;
* активные и пассивные health-checks, исключение из балансировки до восстановления.

### Плагины

Фильтры в виде перечисления вариантов без виртуальных вызовов:

* встроенные: logger, rate limiter, headers, cors, ip allow/deny, простая авторизация по заголовку, маскирование чувствительных полей;
* конфигурация плагинов через сериализуемые структуры;
* динамические плагины как отдельная фича через cdylib или WASM, выключена по умолчанию и не рекомендуется для горячего пути.

## Конфигурация

### Формат

YAML, JSON или TOML. Переменные окружения для переопределений. Горячая перезагрузка по сигналу с атомарной заменой подготовленных структур.

### Секции

* server: параметры сокета, воркеров, буферов, таймаутов, keep-alive, ограничения на тело запроса, параметры TCP;
* tls: путь к сертификату и ключу, список протоколов ALPN, параметры OCSP;
* proxy: таймауты, проверки, лимиты, балансировка, политика повторов, коды ошибок для шлюзовых ситуаций, запись заголовков X-Forwarded и Forwarded, переписывание Host;
* static: корень, список индексных имён, SPA-fallback, заголовки кеширования, диапазоны, ETag, настройки компрессии, автоотдача предварительно сжатых ресурсов;
* plugins: список фильтров с конфигами;
* groups: группы маршрутов с локальными переопределениями proxy, static и plugins;
* routes: декларативный DSL на строках.

### DSL маршрутизации

#### Грамматика

* строка: методы опционально, затем путь, двоеточие, затем действие;
* методы: одно или несколько значений из списка GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS, либо звёздочка для всех;
* путь: абсолютный путь с сегментами, допускаются `:name` и маска `*` в хвосте;
* действие:

  * прокси: абсолютный URI до апстрима, допускается префикс-директория;
  * статика: абсолютный или относительный путь к каталогу;
  * фиксированный ответ: статус и, опционально, JSON или текст до конца строки;
  * echo: звёздочка и, опционально, статус;
* статус: ключевое слово из набора OK, CREATED, ACCEPTED, NO_CONTENT, MOVED, FOUND, SEE_OTHER, NOT_MODIFIED, TEMP_REDIRECT, PERM_REDIRECT, BAD_REQUEST, UNAUTHORIZED, FORBIDDEN, NOT_FOUND, METHOD_NOT_ALLOWED, CONFLICT, GONE, TOO_MANY_REQUESTS, INTERNAL_ERROR, NOT_IMPLEMENTED, BAD_GATEWAY, SERVICE_UNAVAILABLE, GATEWAY_TIMEOUT, либо трёхзначный код в конфиге, при этом в документации допускается использование ключевых слов.

#### Примеры

```
routes:
  "/": "/dist/"
  "/ping": "http://auth/ping"
  GET POST PATCH /api/mock/rude: FORBIDDEN {"msg":"GO PATCH UR MUM!"}
  GET /fastest/ever/ok: OK
  /a/b/c: *
  /a/b/c-forbidden: FORBIDDEN *
```

#### Правила выбора

* приоритет по методу, затем по длине и специфичности пути, затем по порядку объявления;
* префиксная прокси-директория не дублирует префикс целевого URI;
* параметры `:name` и хвостовая маска передаются в контекст для фильтров и могут использоваться для формирования заголовков.

## Режимы и поведение

### Proxy

* поддержка keep-alive, как классического HTTP, так и мультиплексированного;
* настройка таймаутов на соединение, чтение и запись;
* балансировка round-robin и по наименьшему числу активных соединений;
* доступные повторные попытки для идемпотентных методов с джиттером, исключение из пула при сетевых ошибках и шлюзовых ответах;
* circuit-breaker с порогами ошибок и окнами наблюдений;
* управление заголовками Host, X-Forwarded-For, X-Forwarded-Proto и Forwarded.

### Static

* direct-path через sendfile, иначе mmap и writev;
* корректная обработка ETag и Last-Modified, ответы без тела при условном запросе;
* поддержка диапазонов, многочастные диапазоны;
* history-fallback для SPA;
* on-the-fly компрессия с ограничением использования CPU и возможностью отключения;
* автоотдача заранее сжатых файлов по согласованию Accept-Encoding.

### Fixed

* мгновенный ответ статусом, опциональное тело в JSON или виде текста;
* автоматический выбор Content-Type, возможность переопределения.

### Echo

* возврат метода, пути, заголовков и первых байт тела по лимиту;
* опциональный статус.

## Плагины и фильтры

### Контракт

```
trait Filter {
    fn pre(&self, ctx: &mut Ctx) -> Result<(), ActionOverride>;
    fn post(&self, ctx: &mut Ctx) -> Result<(), ()>;
}
```

### Встроенные фильтры

* logger: структурные логи, маскирование секретов;
* rate limiter: token или leaky bucket, области применения ip, маршрут, связка ip-маршрут;
* headers: добавление, удаление, замена;
* cors: настройка источников, методов, заголовков, длительности кэша;
* ip allow/deny: белые и чёрные списки;
* auth: проверка заголовка с секретом или простого токена, возможность вынести в внешний провайдер.

## Наблюдаемость

* логи в JSON либо в человекочитаемом виде, уровни, трасс-идентификаторы;
* метрики Prometheus с разбиением по маршрутам и группам, основные гистограммы задержек и счётчики кодов;
* трассировка через OpenTelemetry, экспорт в совместимые бекенды.

## Безопасность

* TLS и mTLS по маршрутам и группам;
* ограничение прав процесса, смена пользователя и группы, chroot или sandbox корня статики;
* нормализация и валидация заголовков и путей, защита от медленных клиентов, лимиты на заголовки и тело;
* безопасные сообщения об ошибках без утечек внутренней информации.

## Надёжность

* обратное давление на чтение и запись, защита от переполнения очередей;
* политики повторов только для идемпотентных операций;
* устойчивый hot-reload без разрыва активных keep-alive соединений;
* детерминированное завершение с дренажом.

## CLI и упаковка

* `anygate serve -c config.yml` — запуск с конфигом;
* `anygate check -c config.yml` — статическая проверка и печать дерева маршрутов;
* `anygate pack-spa --from ./dist --to /dist` — подготовка слоёв для контейнера;
* образ без дистрибутивной базы, пользователь без прав суперпользователя, открытые порты объявляются на уровне оркестратора.

## Бенчмаркинг и приёмка

* сценарии: фиксированный ответ без тела, статика малого размера из кеша, проксирование без тела, проксирование с телом;
* методика: закрепление прерываний на ядрах, увеличение лимитов дескрипторов, тюнинг сетевых параметров, повторяемые серии;
* критерии приёмки: задержка на уровнях высоких квантилей не хуже зрелых решений, пропускная способность не ниже, ошибки отсутствуют, память растёт линейно от числа воркеров и объёма конфигурации.

## Дорожная карта

### Этап основной

* сервер, TLS, конфиг-загрузка и валидация;
* DSL-парсер и компиляция в trie, параметры и маски;
* действия Fixed и Echo;
* раздача статики: sendfile, mmap, index, SPA-fallback, ETag, range, gzip и brotli;
* прокси классический и мультиплексированный с пулами, таймаутами и заголовками X-Forwarded;
* встроенные фильтры logger и rate limiter, headers, cors, ip allow/deny, auth;
* метрики Prometheus, логи, простая трассировка;
* hot-reload и управляемое завершение;
* контейнер и минимальный образ.

### Этап расширенный

* балансировка по наименьшему числу активных соединений, health-checks, circuit-breaker, retries с джиттером;
* автоотдача предварительно сжатых ресурсов и расширенная политика кэширования;
* gRPC passthrough и h2c;
* HTTP поверх QUIC как фича.

### Этап производительности

* io_uring как фича, оптимизация горячего пути, LRU для мелких файлов, расширенные write-схемы;
* профилирование и устранение аллокаций, расширение пулов.

## Поставляемые артефакты

* исходный код, unit и integration тесты, набор сценариев для fuzz;
* утилиты бенчмаркинга и скрипты развёртывания стендов;
* Dockerfile и вспомогательные манифесты для оркестраторов;
* документация: README, руководство по конфигу, описание DSL, руководство по бенчам и тюнингу.

## Зависимости

* rustls, quinn как фича для QUIC, h2, httparse, http, bytes, ahash, parking_lot, tokio-compat как фича, prometheus, opentelemetry, flate2, brotli, zstd, nix, serde и семейство форматов.

## Соответствие «клятве заказчику»

* SPA из контейнера: `"/": "/dist/"`;
* простая прокси на внутренний сервис: `"/ping": "http://auth/ping"`;
* фиксированный запрет для заданных методов с сообщением: `GET POST PATCH /api/mock/rude: FORBIDDEN {"msg":"GO PATCH UR MUM!"}`;
* мгновенный успешный ответ: `GET /fastest/ever/ok: OK`;
* диагностический echo: `/a/b/c: *`;
* echo с пользовательским статусом запрета: `/a/b/c-forbidden: FORBIDDEN *`.
